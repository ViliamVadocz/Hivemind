// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace rlbot.flat
{

using global::System;
using global::FlatBuffers;

public struct MatchSettings : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static MatchSettings GetRootAsMatchSettings(ByteBuffer _bb) { return GetRootAsMatchSettings(_bb, new MatchSettings()); }
  public static MatchSettings GetRootAsMatchSettings(ByteBuffer _bb, MatchSettings obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
  public MatchSettings __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public PlayerConfiguration? PlayerConfigurations(int j) { int o = __p.__offset(4); return o != 0 ? (PlayerConfiguration?)(new PlayerConfiguration()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PlayerConfigurationsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  public GameMode GameMode { get { int o = __p.__offset(6); return o != 0 ? (GameMode)__p.bb.GetSbyte(o + __p.bb_pos) : GameMode.Soccer; } }
  public GameMap GameMap { get { int o = __p.__offset(8); return o != 0 ? (GameMap)__p.bb.GetSbyte(o + __p.bb_pos) : GameMap.DFHStadium; } }
  public bool SkipReplays { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool InstantStart { get { int o = __p.__offset(12); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public MutatorSettings? MutatorSettings { get { int o = __p.__offset(14); return o != 0 ? (MutatorSettings?)(new MutatorSettings()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public ExistingMatchBehavior ExistingMatchBehavior { get { int o = __p.__offset(16); return o != 0 ? (ExistingMatchBehavior)__p.bb.GetSbyte(o + __p.bb_pos) : ExistingMatchBehavior.Restart_If_Different; } }
  public bool EnableLockstep { get { int o = __p.__offset(18); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<MatchSettings> CreateMatchSettings(FlatBufferBuilder builder,
      VectorOffset playerConfigurationsOffset = default(VectorOffset),
      GameMode gameMode = GameMode.Soccer,
      GameMap gameMap = GameMap.DFHStadium,
      bool skipReplays = false,
      bool instantStart = false,
      Offset<MutatorSettings> mutatorSettingsOffset = default(Offset<MutatorSettings>),
      ExistingMatchBehavior existingMatchBehavior = ExistingMatchBehavior.Restart_If_Different,
      bool enableLockstep = false) {
    builder.StartObject(8);
    MatchSettings.AddMutatorSettings(builder, mutatorSettingsOffset);
    MatchSettings.AddPlayerConfigurations(builder, playerConfigurationsOffset);
    MatchSettings.AddEnableLockstep(builder, enableLockstep);
    MatchSettings.AddExistingMatchBehavior(builder, existingMatchBehavior);
    MatchSettings.AddInstantStart(builder, instantStart);
    MatchSettings.AddSkipReplays(builder, skipReplays);
    MatchSettings.AddGameMap(builder, gameMap);
    MatchSettings.AddGameMode(builder, gameMode);
    return MatchSettings.EndMatchSettings(builder);
  }

  public static void StartMatchSettings(FlatBufferBuilder builder) { builder.StartObject(8); }
  public static void AddPlayerConfigurations(FlatBufferBuilder builder, VectorOffset playerConfigurationsOffset) { builder.AddOffset(0, playerConfigurationsOffset.Value, 0); }
  public static VectorOffset CreatePlayerConfigurationsVector(FlatBufferBuilder builder, Offset<PlayerConfiguration>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static void StartPlayerConfigurationsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddGameMode(FlatBufferBuilder builder, GameMode gameMode) { builder.AddSbyte(1, (sbyte)gameMode, 0); }
  public static void AddGameMap(FlatBufferBuilder builder, GameMap gameMap) { builder.AddSbyte(2, (sbyte)gameMap, 0); }
  public static void AddSkipReplays(FlatBufferBuilder builder, bool skipReplays) { builder.AddBool(3, skipReplays, false); }
  public static void AddInstantStart(FlatBufferBuilder builder, bool instantStart) { builder.AddBool(4, instantStart, false); }
  public static void AddMutatorSettings(FlatBufferBuilder builder, Offset<MutatorSettings> mutatorSettingsOffset) { builder.AddOffset(5, mutatorSettingsOffset.Value, 0); }
  public static void AddExistingMatchBehavior(FlatBufferBuilder builder, ExistingMatchBehavior existingMatchBehavior) { builder.AddSbyte(6, (sbyte)existingMatchBehavior, 0); }
  public static void AddEnableLockstep(FlatBufferBuilder builder, bool enableLockstep) { builder.AddBool(7, enableLockstep, false); }
  public static Offset<MatchSettings> EndMatchSettings(FlatBufferBuilder builder) {
    int o = builder.EndObject();
    return new Offset<MatchSettings>(o);
  }
};


}
